# 匿名类

未使用匿名类

```java
abstract class Person {
    public abstract void eat();
}

// interface Person {
//   void eat();
// }

class Child extends Person {
    public void eat() {
        System.out.println("eat something");
    }
}

// class Chile implements Person {
//     public void eat() {
//         System.out.println("eat something");
//     }
// }

public class Demo {
    public static void main(String[] args) {
        Person p = new Child();
        p.eat();
    }
}
```

使用匿名类

```java
abstract class Person {
    public abstract void eat();
}

// interface Person {
//   void eat();
// }

public class Demo {
    public static void main(String[] args) {
        Person p = new Person() { // Person 可以是一个抽象类、接口、类
            @Override
            public void eat() {
                System.out.println("eat something");
            }
        }; // 注意结尾的；
    }
}
```

```java
new Person() {
    @Override
    public void eat() {
        System.out.println("eat something");
    }
};
```

如果Person是一个接口，则上面代码相当于先定义一个实现接口Person的类(即匿名类)，然后通过默认构造方法实例化该类，并重写接口Person里定义的方法，返回的实例对象自动向上转型为Person的引用。

匿名类的好处是少维护一个class。

上面的接口是个函数式接口（有且仅有一个抽象方法，但是可以有多个非抽象方法的接口），可以使用Java8新特性lambda进一步简化代码

```java
@FunctionalInterface
interface Person() {
    void eat();
}

public class Demo {
    public static void main(String[] args) {
        Person p = () -> System.out.println("eat something");
    }
}
```
